27)

One web programming principle that I have understand is responsive design and can apply with confidence.

28)

a) In my assignment 1's implementation of responsive design was important since it makes sure that the webpage is accessible and easy to use regardless of the device and screen being used to see it. Responsive design is essential to reach more people and offer a smooth user experience as people access online content from a variety of devices with different screen sizes and resolutions.

b) The two approaches are:

1) Media Query

Media queries are used to dynamically apply styles to items based on the user's device's specifications, usually using the viewport width. It makes sure that styles are only applied when the prerequisites are satisfied, enabling distinct styling for various screen sizes.

The code snippets from my assignment 1 for media query is pasted below:



/* Media query for screens with a minimum width of 600px (desktop screens) */

@media (min-width: 600px) {



    #left-column,

    #right-column {

        width: 50%;

        /* Sets the width of the columns to 50% for a two-column layout on desktop screens */

        float: left;

        /* Floats the columns to create a two-column layout on desktop screens */

        background-color: grey;

        /* Sets the background color of the columns to grey on desktop screens */

    }



}



In my assignment 1, the media query adjusts the layout for larger screens by floating the columns to form a two-column layout, each taking up 50% of the width of the container. This media query applies the supplied styles when the viewport width is 600px or higher.

This method of implementing media queries enables adjustments for various screen sizes. By automatically modifying the layout based on the available screen, it makes sure that the webpage layout is user-friendly and visually appealing, not just on computers but also on tablets and mobile devices, offering an ideal viewing experience.



2) Grid Layout (fluid)

A fluid grid layout uses percentage widths instead of fixed pixel widths for elements, allowing them to resize relative to their container, and adapt to different screen sizes and orientations.



The code snippets from my assignment 1 for grid layout (fluid) is pasted below:


/* Styling for the navigation bar */
nav {
    width: 100%;
    /* Sets the width of the navigation bar to 100% */
    text-align: center;
    /* Centers the navigation links */
    border-bottom: 1px solid #000;
    /* Adds a 1px black solid line at the bottom of the navigation bar */
    background-color: greenyellow;
    /* Sets the background color of the navigation bar to green yellow */
    padding: 2vw;
    /* Adds padding around the navigation links */
}
.....
.....
/* Styling for the left and right columns */
#left-column,
#right-column {
    float: none;
    /* Resets any previous float property to none */
    width: 100%;
    /* Sets the width of the columns to 100% */
    background-color: #f5f5f5;
    /* Sets the background color of the columns to light grey */
}

Here, the width of the navigation bar and the columns are set to 100% of their container, enabling them to stretch and shrink as the viewport changes, maintaining a fluid and flexible layout.
The implementation of a fluid grid layout with percentage widths ensures that elements on the webpage are scalable and adaptable to different screen sizes and resolutions. It contributes to a more flexible and responsive design, preventing the webpage from breaking or becoming distorted, and ensuring a seamless and consistent user experience across various devices.

29)

a) Another web programming principle that I have understand is validation on client-side.

b) In the context of my assignment 2, the principle of client-side validation was important as it ensures that the user has filled out the form correctly before it is submitted, thus enhancing the user's experience, and reducing the load on the server wherever necessary. Client-side validation is the process of verifying user input before it is submitted to the server, often within the user's browser to increase the efficiency of the server and its response.

c) In my assignment 2, client-side validation was implemented using a combination of Event Listeners, Conditional Statements, and Pattern Matching. Out of these, I will describe pattern matching.

My assignment 2 uses regular expressions to validate the format of the userâ€™s input in the email input text field.

The code snippets from my assignment 2 for pattern matching is pasted below:

// Validation for the email field.

    else if (!emailInput.value.match(/^[a-zA-Z-]([\w-.]+)?@([\w-]+\.)+[\w]+$/)) {

        emailInput.setCustomValidity('Invalid email! Please enter a valid email address.');

        valid = false;

    }



In the snippet of my code from assignment 2, a regular expression is used to match the value of the email input against a pattern representing a valid email address format. If the input does not match, a custom validity message is set, and the valid flag is marked as false.

The ability to match user input easily and dynamically against predefined patterns using regular expressions is a valuable technique for performing client-side validation. This ensures data is accurate and complies to expected forms.

30)

a) ONE web programming principle or technique that I feel I don't have a good grasp on is making asynchronous requests.

b) The technique of "making asynchronous requests" in my assignment 3, mostly has to do with sending network requests that don't pause the program's main execution thread so that other processes may carry on while the request is being processed. This is significant in web development, because maintaining a responsive user interface is essential. A bad user experience would result if the queries were synchronous, and the user interface became unusable.

In my assignment 3, while making an asynchronous request using jQuery's ajax method, 

It makes a POST request to a URL (stored in the variable url).

It sends data serialized from a form with the ID registration.

If the request is successful, it logs the password received from the server to the console and displays a message to the user.

If the request encounters an error, it logs the raw response and attempts to parse and log/display the error message.

The code snippets from my assignment 3 for making asynchronous requests is pasted below:



  // make request

  $.ajax({

    url: url,

    method: 'POST',

    data: $('#registration').serialize(),

    dataType: 'json',

    success: function (data) {

      // log temporary password to console

      console.log('password : ' + data.password);



      // display user_id on page

      $('#server_response').addClass('success');

      $('#server_response span').html('Congratulations!<br>Your temporary password is : ' + data.password);

    },

    error: function (jqXHR) {

      // Log the raw response to the console

      console.log("Raw server response:", jqXHR.responseText);

      // parse JSON

      try {

        var $e = JSON.parse(jqXHR.responseText);



        // log error to console

        console.log('Error from server: ' + $e.error);



        // display error on page

        $('#server_response').addClass('error');

        $('#server_response span').text('Error from server: ' + $e.code + ' ' + $e.status + ' : ' + $e.error);

      }

      catch (error) {

        console.log('Could not parse JSON error message: ' + error);

      }

    }

  });

31)

a) I have used passive white space to create a margin between the body of the page and the edges of the screen, and to separate the different sections of the page. I have added a margin between the navigation bar and the header section, and between the different columns on the page.

I have used active white space to highlight the main heading and subheadings on my page. For example, I have added a large margin around the main heading, and I have added a smaller margin around the subheadings. I have also used active white space to separate the different sections of the page. For example, I have added a large margin between the "More" section and the contact details section.

b) Three features of my webpage that demonstrate that I have defined the look for the user are consistent use of typography, use of colour and use of images.

c) Three features of my webpage that demonstrate that I have designed the feel for interaction are use of hover effects, use of large buttons and use of clear language.

d) Yes, hypertext linking is used in my design, primarily within the navigation bar and in the left column for email and phone and in the right column just to lead to the respective sections as well. The hyperlinks are supposed to lead to different sections or pages (which is not implemented in actual) of the website.

e) If I were to re-attempt this task, I would improve accessibility by using more contrasting colours to ensure readability and accessibility. For instance, the text colour in the footer section on a red background might not be easily readable for everyone, especially those with visual impairments.

32)

I have written only the CSS part to save the time making assumptions that there is appropriate HTML part of code already exists.

The assumptions are:

1) The class block to each of the blocks of text of western astrological star signs exists.

2) All the blocks in a container are wrapped with the class blocks-container.


Now, CSS part (formatted using sublime text 4)...


.block {

    box-sizing: border-box;

    width: 100%;

    margin-bottom: 20px;

}

@media (min-width: 351px) and (max-width: 719px) {

    .block {

        width: calc(50% - 10px);

        float: left;

        &:nth-child(2n) {

            margin-right: 20px; 

        }

    }

}

@media (min-width: 721px) {

    .block {

        width: calc(33.3333% - 13.3333px);

        float: left;

        &:nth-child(3n+1),

        &:nth-child(3n+2) {

            margin-right: 20px; 

        }

    }

}

.blocks-container:after {

    content: "";

    display: table;

    clear: both;

}

33)

function Geek(name, dateOfBirth) {

    this.name = name;

    this.dateOfBirth = new Date(dateOfBirth); // YYYY-MM-DD

    this.getGeneration = function() {

        const year = this.dateOfBirth.getFullYear();

        if (year < 1946) return "The Builders";

        if (year >= 1946 && year <= 1964) return "Baby Boomers";

        if (year >= 1965 && year <= 1979) return "Generation X";

        if (year >= 1980 && year <= 1994) return "Generation Y";

        if (year >= 1995 && year <= 2009) return "Generation Z";

        if (year >= 2010 && year <= 2024) return "Generation Alpha";

    };

    this.getStarSign = function() {

        const month = this.dateOfBirth.getMonth() + 1;

        const day = this.dateOfBirth.getDate();

        if ((month === 3 && day >= 21) || (month === 4 && day <= 19)) return "Aries";

        if ((month === 4 && day >= 20) || (month === 5 && day <= 20)) return "Taurus";

        if ((month === 5 && day >= 21) || (month === 6 && day <= 20)) return "Gemini";

        if ((month === 6 && day >= 21) || (month === 7 && day <= 22)) return "Cancer";

        if ((month === 7 && day >= 23) || (month === 8 && day <= 22)) return "Leo";

        if ((month === 8 && day >= 23) || (month === 9 && day <= 22)) return "Virgo";

        if ((month === 9 && day >= 23) || (month === 10 && day <= 22)) return "Libra";

        if ((month === 10 && day >= 23) || (month === 11 && day <= 21)) return "Scorpio";

        if ((month === 11 && day >= 22) || (month === 12 && day <= 21)) return "Sagittarius";

        if ((month === 12 && day >= 22) || (month === 1 && day <= 19)) return "Capricorn";

        if ((month === 1 && day >= 20) || (month === 2 && day <= 18)) return "Aquarius";

        if ((month === 2 && day >= 19) || (month === 3 && day <= 20)) return "Pisces";

};

}

34)

The primary drawback of defining methods this way is that each instance of the Geek object will have its own copy of the getGeneration and getStarSign functions. This is not memory-efficient, especially when creating many instances of the object, as each instance will have separate copies of the same functions in memory.
A better approach would be to define these methods on the Geek prototype. When methods are added to the prototype, all instances of the object share the same method, making it more memory-efficient.
Below is the new revised code:

function Geek(name, dateOfBirth) {

    this.name = name;

    this.dateOfBirth = new Date(dateOfBirth); // YYYY-MM-DD

}

Geek.prototype.getGeneration = function() {

    const year = this.dateOfBirth.getFullYear();

    if (year < 1946) return "The Builders";

    if (year >= 1946 && year <= 1964) return "Baby Boomers";

    if (year >= 1965 && year <= 1979) return "Generation X";

    if (year >= 1980 && year <= 1994) return "Generation Y";

    if (year >= 1995 && year <= 2009) return "Generation Z";

    if (year >= 2010 && year <= 2024) return "Generation Alpha";

};

Geek.prototype.getStarSign = function() {

    const month = this.dateOfBirth.getMonth() + 1;

    const day = this.dateOfBirth.getDate();

    if ((month === 3 && day >= 21) || (month === 4 && day <= 19)) return "Aries";

    if ((month === 4 && day >= 20) || (month === 5 && day <= 20)) return "Taurus";

    if ((month === 5 && day >= 21) || (month === 6 && day <= 20)) return "Gemini";

    if ((month === 6 && day >= 21) || (month === 7 && day <= 22)) return "Cancer";

    if ((month === 7 && day >= 23) || (month === 8 && day <= 22)) return "Leo";

    if ((month === 8 && day >= 23) || (month === 9 && day <= 22)) return "Virgo";

    if ((month === 9 && day >= 23) || (month === 10 && day <= 22)) return "Libra";

    if ((month === 10 && day >= 23) || (month === 11 && day <= 21)) return "Scorpio";

    if ((month === 11 && day >= 22) || (month === 12 && day <= 21)) return "Sagittarius";

    if ((month === 12 && day >= 22) || (month === 1 && day <= 19)) return "Capricorn";

    if ((month === 1 && day >= 20) || (month === 2 && day <= 18)) return "Aquarius";

    if ((month === 2 && day >= 19) || (month === 3 && day <= 20)) return "Pisces";

};

35)

function checkFileSize() {

    const fileInput = document.getElementById('fileInput');

    if (fileInput.files.length > 0) {

        const file = fileInput.files[0];

        const fileSizeInBytes = file.size;

        const fileSizeInMB = fileSizeInBytes / (1024 * 1024); // Converting to MB

        if (fileSizeInMB < 50) {

            alert('File size is too small. Please upload a file between 50MB and 250MB.');

            fileInput.value = '';

        } else if (fileSizeInMB > 250) {

            alert('File size is too large. Please upload a file between 50MB and 250MB.');

            fileInput.value = '';

        } else {

            alert('File size is within the allowed limits.');

        }

    }

}



The limitations of this approach could be client-side validation only, dependent on modern browser support and also it does not prevent the user from submitting less or over sized files.

36)

<?php

$minFileSize = 50 * 1024 * 1024;

$maxFileSize = 250 * 1024 * 1024;

if (isset($_FILES['uploadedFile'])) {

    $fileSize = $_FILES['uploadedFile']['size'];

    if ($fileSize < $minFileSize) {

        echo "Error: File size is too small. Please upload a file between 50MB and 250MB.";

    } elseif ($fileSize > $maxFileSize) {

        echo "Error: File size is too large. Please upload a file between 50MB and 250MB.";

    } else {

        move_uploaded_file($_FILES['uploadedFile']['tmp_name'], 'uploads/' . $_FILES['uploadedFile']['name']);

        echo "File uploaded successfully.";

    }

} else {

    echo "Error: No file was uploaded.";

}

?>



The code provided in a) is the most effective way of regulating file size because of the following reasons.

To prevent hacking and ensure security, this PHP code validates file sizes on the server. Server-side validation makes sure that huge files are rejected before they may create problems, unlike client-side validation, which can be manipulated easily.

The server-side logic consistently enforces the file size limitations, regardless of the client or browser being used. For all users, regardless of their client configurations, this guarantees uniform behaviour.

Maintaining data integrity and avoiding server resource weakness, which could happen if huge files are handled, is possible by rejecting larger files at the server level.

37)

<?php

class StarSign implements JsonSerializable {

    private $name;

    private $startDate;

    private $endDate;

    private $zodiacElement;



    public function __construct($name, $startDate, $endDate, $zodiacElement) {

        $this->name = $name;

        $this->startDate = $startDate;

        $this->endDate = $endDate;

        $this->zodiacElement = $zodiacElement;

    }



    public function jsonSerialize() {

        return [

            'name' => $this->name,

            'startDate' => $this->startDate,

            'endDate' => $this->endDate,

            'zodiacElement' => $this->zodiacElement

        ];

    }

}

?>

<?php

$starSigns = [

    new StarSign("Capricorn", "Dec 22", "Jan 19", "Earth"),

    new StarSign("Aquarius", "Jan 20", "Feb 18", "Air"),

    new StarSign("Pisces", "Feb 19", "Mar 20", "Water"),

];

?>







